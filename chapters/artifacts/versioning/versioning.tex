%! TEX root = ../../../main.tex

\section{Versioning}%
\label{sec:Versioning}

\subsection{The Need for Good Versioning Conventions}%
\label{sub:The_Need_for_Good_Versioning_Conventions}
Unlike in the monolithic architecture, a continuously deployed microservice
architecture is comprised of many components that each have their own version.
Hence it has to be decided case by case which versioning scheme best fits each
microservice. Further, as many microservices provide some kind of \ac{API}
(mostly \ac{REST}) some form of versioning has to be used. Without versioning,
the application implementing the \ac{API} would always consume the latest
version of the microservice. This implies that any non-backward-compatible
update to the microservice would break all client implementations of the
microservice's \ac{API}. Not only is the client able to pin its implementation
to a specific \ac{API} version. The client is further able to select any
version of a resource that best fits its implementation. In addition, a good
versioning scheme allows developers to quickly assess whether a new version
breaks the service's backward-compatibility. Lastly, microservice do not only
provide services to other microservices. E.g.\ a \textit{frontend} microservice
directly serves the end user. Hence the versioning scheme used in such a
microservice also serves a communicative purpose.

\subsection{Versioning in a Conventions Microservice Environment}%
\label{sub:Versioning_in_a_Microservice_Environment}
Chapter~\ref{sub:Versioning} already introduced the two main versioning schemes
\textit{SemVer} and \textit{CalVer}. As microservices mostly provide their
\ac{API} through the \ac{REST} paradigm, the chapter also presented the three
main possibilities to version a \ac{REST} \ac{API}.

Based on this theoretical foundation, it is the aim to develop a model that
shows how a microservice can be versioned. In addition, it is the goal to
define a process that helps developers to choose the best versioning model for
their given application.

It might seem like that monolithic and microservice applications
follow the same conventions in regards to versioning; at least both application
types are versioned in some form. In addition their code base is stored and
tracked in some form of \ac{VCS}. However they have to be handled quite
differently. Due to their high deployment complexity a microservice
architecture is still primarily employed in the cloud applications. There are a
few ways the microservice architecture can be brought to desktop software.
However due to the definitions of microservices this thesis explored to far,
the upcoming section will only focus on microservice applications that are
deployed in the cloud. In that case, two possible ways of distribution prevail:
distribution as a \ac{SaaS} product or as a software package (e.g.\ in form of
a Helm chart) in the customers cloud environment. In the case of a \ac{SaaS}
solution, the user never interacts with the installation, configuration and
upgrade process. Given the application is deployed by the user inside their
cloud environment, only the version number of the complete software package is
of interest. Even though a microservice architecture is made up of a set of
microservices, the only component a user, in this case an administrator
deploying the application, ever touches is the microservice architecture's
package (e.g.\ a helm chart). Narrowing it further down, this thesis will only
focus on cloud applications that are deployed as part of a \ac{SaaS} product
because of the interest in a continuously deployed microservice architecture.
Yet it is feasible to bring continuous deployment to self-hosted microservice
architectures, this is out of this thesis' scope. From a microservice
architecture developer's perspective, the source code of each microservice is
managed in separate repository inside a \ac{VCS}. This introduces complexity
but also brings the advantage of distinct build configurations if these are
stored in configuration files next to the service's code.

Now that the properties of monolithic and microservice architecture versioning
are recorded, the question of which versioning scheme best fits a microservice
architecture can be addressed. In order to do so, microservices can be divided
into two categories: \textit{Human Interaction} and \textit{Machine
Interaction}. A microservice can be classified in the Human Interaction
category if it mainly used by humans. This is e.g.\ the case for frontend
microservices and other \textit{consuming} parts. On the other hand, a
microservice can be classified in the Machine Interacting category whenever it
mainly talks to other machines or its functionality is integrated in other
microservices in a library like fashion. Such services can also be considered
to be \textit{producing} parts.

\LTXtable{\textwidth}{tables/versioning_machine_human.tex}

Table \ref{tab:versioning_machine_human} shows a selected set of properties
that is required for versioning a microservice. It groups the requirements into
the two microservice categories \textit{Human Interaction} and \textit{Machine
Interaction}. It can be concluded that the versioning of \textit{consuming}
services mainly serves a communicative purpose whereas versioning in
\textit{producing} services plays a technical role. Hence it can be argued that
for microservices which are mainly in direct contact with humans, the version
number is an indicator for features. Thus e.g.\ version 16 of a frontend might
introduce a feature that gives the user more editing capabilities. This added
value can then be clearly communicated using the release's version number.

In a microservice environment these four components can be identified to
receive version numbers (in reverse order of atomicity):

\begin{itemize}
  \item Packaged software (e.g.\ Helm charts)
  \item Container images
  \item Software (e.g.\ Node.js projects)
  \item \acp{API}
\end{itemize}

So far, this section already explored the general issues related to versioning
a microservice. The requirement however demands that the microservices are also
continuously deployed. Despite the fact that an automated build and deployment
process can reduce the workload of a developer and administrator, it introduces
an additional facet of complexity. Whenever a microservice is continuously
built and deployed, it has to be decided who has to bump the version number.
Schemes like SemVer require manual version bumping whereas date-based schemas
like CalVer can be incremented without manual intervention. The reason why
SemVer requires input by a developer is that with each version bump the type of
version increase has to be determined. Each time the version in incremented
these three questions have to be asked:

\begin{itemize}
  \item Does this update only introduce fixes?
  \item Does this update include any new features?
  \item Does this update break the software's backward compatibility?
\end{itemize}

According to the answers to these questions, only the correct part of the
version number has to be modified. The rules for when to update which part of a
SemVer version number are already discussed in chapter~\ref{ssub:SemVer}. These
question however can not be answered by a \ac{CI} solution that is not able to
able to understand the intricate differences between a e.g.\ backward
compatibility breaking update and a simple bug fix. Hence it can be argued that
a versioning scheme that requires artificial decisions from developers can not
be fully supported by \ac{CI} systems. For each new version, the developers
have to manually write the new version number in the applications
configuration. E.g.\ in case of Node.js application, the \texttt{version} field
inside the \texttt{package.json} file has to be updated.

In contrast, date-based versioning schemes like CalVer can update the version
number without further intervention developers. As already discussed in
chapter~\ref{ssub:Date_Based_Versioning}, in most cases a CalVer version number
only includes the formatted date of the release.
Chapter~\ref{ssub:Continuous_Integration} already stated that any software that
is considered to be stable can be used as a release. Thus the \ac{CI} system
can automatically generate a valid date-based version number and inject it in
the software package. Next to the actual application, the same principles can
be applied to packaged software and container images.

Yet, when it comes to \acp{API}, an exception must me made. As pointed out in
chapter~\ref{ssub:API_Versioning}, the usage of \acp{API} heavily depends on
specific \ac{API} versions.

Nur Software, die wirklich auf das ausweisen der backward comp angewiesen ist,
sollte ein solch manuelles Schema wÃ¤hlen! -> Beziehen auf die Consumer und
Producer.

\subsection{Evaluating XXX Versioning}%
\label{sub:Evaluating_XXX_Versioning}

\subsection{Advancing Continuous Deployment of Microservices using XXX Versioning}%
\label{sub:Advancing_Continuous_Deployment_of_Microservices_using_XXX_Versioning}

\subsection{Economic benefits of XXX Versioning}%
\label{sub:Economic_benefits_of_XXX_Versioning}

