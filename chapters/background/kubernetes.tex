%! TEX root = ../../main.tex

\subsection{Kubernetes}%
\label{sub:Kubernetes}

The practise of running microservices in a production environment is not only
used by big technology companies. The United Kingdom government's Department
for Work and Pensions states to be running one of the largest microservice
architectures in Europe. The country's public services \textit{universal
credit} system fully runs as a microservice architecture
\autocite{LoweLeadingwaymicroservices2016}. Yet how is it possible to
orchestrate such a huge amount of microservices?

Kubernetes is a container orchestration solution that is capable of
automatically deploying, scaling and managing containers
\autocite{AuthorsProductionGradeContainer}. It was introduced in 2014 by Google
and is based on the experience Google gained while developing among other
things \textit{Borg} and \textit{Omega}. Borg and Omega were applications
internally developed by Google to manage their thousands of applications and
services \autocite{LuksaKubernetesAction2017}.

This chapter will shortly introduce the main concepts of Kubernetes and give an
overview of the Kubernetes components that are relevant to the research
questions. If needed, The official Kubernetes documentation
\autocite{AuthorsProductionGradeContainer}, which covers all system components
in detail, can be used as a supplement to this thesis.

\subsubsection{Concepts}%
\label{ssub:Concepts}
Kubernetes distinguishes between \textit{master} and \textit{node} components.
The master components, also referred to as \textit{control plane}, are in
charge of managing a cluster. The control plane hosts Kubernetes' API, manages
the clusters configuration and schedules \textit{pods} to run on available
nodes \autocite{AuthorsKubernetesComponents2019}. In general, the master
components are responsible for keeping the cluster alive.

The node components on the other hand are executed on every node of the
cluster. Any node of a Kubernetes cluster runs an agent, \textit{kubelet}, that
ensures that all containers of the node's assigned pods are executed. Further,
a node always runs the network proxy \textit{kube-proxy} that enforces
networking rules and manages the node's traffic. Lastly, a container runtime
allows all of this to happen. As already mentioned in
Chapter~\ref{ssub:Deployment_Runtime_Model}, there are several runtime
environments to chose from. Next to Docker, Kubernetes also directly supports
\textit{containerd}, \textit{crio-o}, \textit{rktlet}
\autocite{AuthorsKubernetesComponents2019}.

\paragraph{Pods}%
\label{par:Pods}
Instead of directly deploying individual containers, Kubernetes introduces the
concept of \textit{pods}. A pod is the smallest entity that can be executed on
the cluster. It hosts at least one containers and automatically receives a
\ac{IP} address that is unique inside Kubernetes. Kubernetes ensures that all
containers of a pod are always executed in the same node.

Yet this does not mean that a complete microservice architecture should be
bundled into one pod.  The decision when to combines microservices into one pod
and when to split them across multiple pods becomes clear in the following
example. Given is an exemplary microservice architecture consisting of a basic
web crawler that fetches all \textit{xkcd} comics from the xkcd archive and
stores them in the file system, a frontend that displays the fetched comics and
a backend that serves the fetches images to the frontend. Both the backend as
well as the crawler have to access the same file system. Further, the backend
would not be able to serve comics without the crawler hence it would fail to
fulfil its task. Thus it can be said that these two services are
\textit{tightly coupled} and are a dependent components. It can also be argued
that the crawler only acts as a supporting component for the actual backend.
Hence, the crawler and backend should be shipped inside the same pod. On the
other hand the frontend is a fully independent system component. It can be
scaled independently from the backend and crawler; it belongs into a separate
pod.

% TODO: Add figure displaying the two pods
