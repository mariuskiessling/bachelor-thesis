%! TEX root = ../../../main.tex

\section{Versioning}%
\label{sec:Versioning}

\subsection{The Need for Good Versioning Conventions}%
\label{sub:The_Need_for_Good_Versioning_Conventions}
Unlike in the monolithic architecture, a continuously deployed microservice
architecture is comprised of many components that each have their own version.
Hence it has to be decided case by case which versioning scheme best fits each
microservice. Further, as many microservices provide some kind of \ac{API}
(mostly \ac{REST}) some form of versioning has to be used. Without versioning,
the application implementing the \ac{API} would always consume the latest
version of the microservice. This implies that any non-backward-compatible
update to the microservice would break all client implementations of the
microservice's \ac{API}. Not only is the client able to pin its implementation
to a specific \ac{API} version. The client is further able to select any
version of a resource that best fits its implementation. In addition, a good
versioning scheme allows developers to quickly assess whether a new version
breaks the service's backward-compatibility. Lastly, microservice do not only
provide services to other microservices. E.g.\ a \textit{frontend} microservice
directly serves the end user. Hence the versioning scheme used in such a
microservice also serves a communicative purpose.

\subsection{Versioning in a Conventions Microservice Environment}%
\label{sub:Versioning_in_a_Microservice_Environment}
Chapter~\ref{sub:Versioning} already introduced the two main versioning schemes
\textit{SemVer} and \textit{CalVer}. As microservices mostly provide their
\ac{API} through the \ac{REST} paradigm, the chapter also presented the three
main possibilities to version a \ac{REST} \ac{API}.

Based on this theoretical foundation, it is the aim to develop a model that
shows how a microservice can be versioned. In addition, it is the goal to
define a process that helps developers to choose the best versioning model for
their given application.

It might seem like that monolithic and microservice applications
follow the same conventions in regards to versioning; at least both application
types are versioned in some form. In addition their code base is stored and
tracked in some form of \ac{VCS}. However they have to be handled quite
differently. Due to their high deployment complexity a microservice
architecture is still primarily employed in the cloud applications. There are a
few ways the microservice architecture can be brought to desktop software.
However due to the definitions of microservices this thesis explored to far,
the upcoming section will only focus on microservice applications that are
deployed in the cloud. In that case, two possible ways of distribution prevail:
distribution as a \ac{SaaS} product or as a software package (e.g.\ in form of
a Helm chart) in the customers cloud environment. In the case of a \ac{SaaS}
solution, the user never interacts with the installation, configuration and
upgrade process. Given the application is deployed by the user inside their
cloud environment, only the version number of the complete software package is
of interest. Even though a microservice architecture is made up of a set of
microservices, the only component a user, in this case an administrator
deploying the application, ever touches is the microservice architecture's
package (e.g.\ a helm chart). Narrowing it further down, this thesis will only
focus on cloud applications that are deployed as part of a \ac{SaaS} product
because of the interest in a continuously deployed microservice architecture.
Yet it is feasible to bring continuous deployment to self-hosted microservice
architectures, this is out of this thesis' scope. From a microservice
architecture developer's perspective, the source code of each microservice is
managed in separate repository inside a \ac{VCS}. This introduces complexity
but also brings the advantage of distinct build configurations if these are
stored in configuration files next to the service's code.

Now that the properties of monolithic and microservice architecture versioning
are recorded, the question of which versioning scheme best fits a microservice
architecture can be addressed. In order to do so, microservices can be divided
into two categories: \textit{Human Interaction} and \textit{Machine
Interaction}. A microservice can be classified in the Human Interaction
category if it mainly used by humans. This is e.g.\ the case for frontend
microservices and other \textit{consuming} parts. On the other hand, a
microservice can be classified in the Machine Interacting category whenever it
mainly talks to other machines or its functionality is integrated in other
microservices in a library like fashion. Such services can also be considered
to be \textit{producing} parts.

\LTXtable{\textwidth}{tables/versioning_machine_human.tex}

\ref{tab:versioning_machine_human} shows a selected set of properties that is
required for versioning a microservice. It groups the requirements into the two
microservice categories \textit{Human Interaction} and \textit{Machine
Interaction}. It can be concluded that the versioning of \textit{consuming}
services mainly serve a communicative purpose whereas versioning in
\textit{producing} services play a technical role. Hence it can be argued that
for microservices which are mainly in direct contact with humans, the version
number is an indicator for features. Thus e.g.\ version 16 of a frontend might
introduce a feature that gives the user more editing capabilities. This added
value can then be clearly communicated using the release's version number.

In a microservice environment these four components can be identified to
receive version numbers (in reverse order of atomicity):
\begin{itemize}
  \item Packaged software (e.g.\ Helm charts)
  \item Container images
  \item Software (e.g.\ in Node.js projects)
  \item \acp{API}
\end{itemize}

So far, this section already explored the general issues related to versioning
a microservice. The requirement however demands that the microservices are also
continuously deployed. Despite an automated build and deployment process can
reduce the workload of a developer and administrator, it introduces an
additional facet of complexity.

\subsection{Evaluating XXX Versioning}%
\label{sub:Evaluating_XXX_Versioning}

\subsection{Advancing Continuous Deployment of Microservices using XXX Versioning}%
\label{sub:Advancing_Continuous_Deployment_of_Microservices_using_XXX_Versioning}

\subsection{Economic benefits of XXX Versioning}%
\label{sub:Economic_benefits_of_XXX_Versioning}

