%! TEX root = ../../../main.tex

\section{Versioning}%
\label{sec:Versioning}

\subsection{The Need for Good Versioning Conventions}%
\label{sub:The_Need_for_Good_Versioning_Conventions}
Unlike in the monolithic architecture, a continuously deployed microservice
architecture is comprised of many components that each have their own version.
Hence it has to be decided case by case which versioning scheme best fits each
microservice. Further, as many microservices provide some kind of \ac{API}
(mostly \ac{REST}) some form of versioning has to be used. Without versioning,
the application implementing the \ac{API} would always consume the latest
version of the microservice. This implies that any non-backward-compatible
update to the microservice would break all client implementations of the
microservice's \ac{API}. Not only is the client able to pin its implementation
to a specific \ac{API} version. The client is further able to select any
version of a resource that best fits its implementation. In addition, a good
versioning scheme allows developers to quickly assess whether a new version
breaks the service's backward-compatibility. Lastly, microservice do not only
provide services to other microservices. E.g.\ a \textit{frontend} microservice
directly serves the end user. Hence the versioning scheme used in such a
microservice also serves a communicative purpose.

\subsection{Versioning in a Conventions Microservice Environment}%
\label{sub:Versioning_in_a_Microservice_Environment}
Chapter~\ref{sub:Versioning} already introduced the two main versioning schemes
\textit{SemVer} and \textit{CalVer}. As microservices mostly provide their
\ac{API} through the \ac{REST} paradigm, the chapter also presented the three
main possibilities to version a \ac{REST} \ac{API}.

Based on this theoretical foundation, it is the aim to develop a model that
shows how a microservice can be versioned. In addition, it is the goal to
define a process that helps developers to choose the best versioning model for
their given application.

\subsubsection{Versioning Monoliths vs.\ Microservices}%
\label{ssub:Versioning Monoliths_vs_Microservices}

It might seem like that monolithic and microservice applications
follow the same conventions in regards to versioning; at least both application
types are versioned in some form. In addition their code base is stored and
tracked in some form of \ac{VCS}. However they have to be handled quite
differently. Due to their high deployment complexity a microservice
architecture is still primarily employed in the cloud applications. There are a
few ways the microservice architecture can be brought to desktop software.
However due to the definitions of microservices this thesis explored to far,
the upcoming section will only focus on microservice applications that are
deployed in the cloud. In that case, two possible ways of distribution prevail:
distribution as a \ac{SaaS} product or as a software package (e.g.\ in form of
a Helm chart) in the customers cloud environment. In the case of a \ac{SaaS}
solution, the user never interacts with the installation, configuration and
upgrade process. Given the application is deployed by the user inside their
cloud environment, only the version number of the complete software package is
of interest. Even though a microservice architecture is made up of a set of
microservices, the only component a user, in this case an administrator
deploying the application, ever touches is the microservice architecture's
package (e.g.\ a helm chart). Narrowing it further down, this thesis will only
focus on cloud applications that are deployed as part of a \ac{SaaS} product
because of the interest in a continuously deployed microservice architecture.
Yet it is feasible to bring continuous deployment to self-hosted microservice
architectures, this is out of this thesis' scope. From a microservice
architecture developer's perspective, the source code of each microservice is
managed in separate repository inside a \ac{VCS}. This introduces complexity
but also brings the advantage of distinct build configurations if these are
stored in configuration files next to the service's code.

Now that the properties of monolithic and microservice architecture versioning
are recorded, the question of which versioning scheme best fits a microservice
architecture can be addressed. In order to do so, microservices can be divided
into two categories: \textit{Human Interaction} and \textit{Machine
Interaction}. A microservice can be classified in the Human Interaction
category if it mainly used by humans. This is e.g.\ the case for frontend
microservices and other \textit{consuming} parts. On the other hand, a
microservice can be classified in the Machine Interacting category whenever it
mainly talks to other machines or its functionality is integrated in other
microservices in a library like fashion. Such services can also be considered
to be \textit{producing} parts.

\LTXtable{\textwidth}{tables/versioning_machine_human.tex}

Table \ref{tab:versioning_machine_human} shows a selected set of properties
that is required for versioning a microservice. It groups the requirements into
the two microservice categories \textit{Human Interaction} and \textit{Machine
Interaction}. It can be concluded that the versioning of \textit{consuming}
services mainly serves a communicative purpose whereas versioning in
\textit{producing} services plays a technical role. Hence it can be argued that
for microservices which are mainly in direct contact with humans, the version
number is an indicator for features. Thus e.g.\ version 16 of a frontend might
introduce a feature that gives the user more editing capabilities. This added
value can then be clearly communicated using the release's version number.

In a microservice environment these four components can be identified to
receive version numbers (in reverse order of atomicity):

\begin{itemize}
  \item Packaged software (e.g.\ Helm charts)
  \item Container images
  \item Software (e.g.\ Node.js projects)
  \item \acp{API}
\end{itemize}

So far, this section already explored the general issues related to versioning
a microservice. The requirement however demands that the microservices are also
continuously deployed. Despite the fact that an automated build and deployment
process can reduce the workload of a developer and administrator, it introduces
an additional facet of complexity. Whenever a microservice is continuously
built and deployed, it has to be decided who has to bump the version number.
Schemes like SemVer require manual version bumping whereas date-based schemas
like CalVer can be incremented without manual intervention. The reason why
SemVer requires input by a developer is that with each version bump the type of
version increase has to be determined. Each time the version in incremented
these three questions have to be asked:

\begin{itemize}
  \item Does this update only introduce fixes?
  \item Does this update include any new features?
  \item Does this update break the software's backward compatibility?
\end{itemize}

According to the answers to these questions, only the correct part of the
version number has to be modified. The rules for when to update which part of a
SemVer version number are already discussed in chapter~\ref{ssub:SemVer}. These
question however can not be answered by a \ac{CI} solution that is not able to
able to understand the intricate differences between a e.g.\ backward
compatibility breaking update and a simple bug fix. Hence it can be argued that
a versioning scheme that requires artificial decisions from developers can not
be fully supported by \ac{CI} systems. For each new version, the developers
have to manually write the new version number in the applications
configuration. E.g.\ in case of Node.js application, the \texttt{version} field
inside the \texttt{package.json} file has to be updated.

In contrast, date-based versioning schemes like CalVer can update the version
number without further intervention developers. As already discussed in
chapter~\ref{ssub:Date_Based_Versioning}, in most cases a CalVer version number
only includes the formatted date of the release.
Chapter~\ref{ssub:Continuous_Integration} already stated that any software that
is considered to be stable can be used as a release. Thus the \ac{CI} system
can automatically generate a valid date-based version number and inject it in
the software package. Next to the actual application, the same principles can
be applied to packaged software and container images.

Yet, when it comes to \acp{API}, an exception must me made. As pointed out in
chapter~\ref{ssub:API_Versioning}, the usage of \acp{API} heavily depends on
pinning to specific \ac{API} versions. To do so, a number of tactics were
already discussed. The most common \ac{API} versioning scheme differs from the
SemVer and CalVer schemes. Instead of choosing a version number that consists
of three parts (\texttt{MAJOR.MINOR.PATCH}) or is date-based, \acp{API} only
announce their major version. If the major version changes, a backward
compatibility breaking change was implemented. Like with SemVer this results in
a manual process that requires application developers to determine if an update
is major.

\begin{figure}[H]
\begin{center}
  \includegraphics[scale=0.7]{images/figures/version_wrapping.pdf}
\end{center}
\caption{Wrapping inner versioning schemes through levels of abstraction.}%
\label{fig:version_wrapping}
\end{figure}

Even though \acp{API} might need a manual versioning scheme, the abstraction
layers above the actual \ac{REST} interface can be versioned differently. As
shown in figure~\ref{fig:version_wrapping}, the application serving the
\ac{REST} interface, in this case a Node.js application, can use an automated
versioning scheme. This way, the \ac{API}'s manual versioning is masked and a
\ac{CI} system can continuously version the software, the resulting container
image and software package. The inner \ac{API} version is wrapped and thus no
longer relevant to the \ac{CI}/\ac{CD} process.

It can thus be argued that an automatic versioning scheme should be used
whenever possible in order to shift the versioning responsibility from
developers to the \ac{CI} system. Only if the software is dependend on marking
a break in its backward compatibility, the version number should be set
manually using a SemVer-like schema. Hence, both applications consuming as well
as producing data can be versioned using an automatic scheme with this
exception.

\subsubsection{Implementation Using Azure DevOps}%
\label{ssub:Implementation_Using_Azure_DevOps}
The \ac{CI}/\ac{CD} service Azure DevOps can be used to show how an automatic
versioning scheme can be implemented in practise. To dynamically generate and
set date-based version numbers, a number of approaches exist. This section will
explore one possible solution.

In Azure DevOps, each microservice is built using a separate pipeline. One of
the properties that can be set for a pipeline is the \textit{build number
format}. Based on this property, a pipeline's build receives a unique identifier
that can also be accessed during the pipeline's run as a variable. In order to
produce a date-based version in the CalVer format \texttt{YYYYMMDD.MINOR}, the
following build number format \texttt{\$(Date:yyyyMMdd).\$(Rev:r)} can be used.
If set to this value, the first build on e.g. November 24th 2019 produces the
build number \texttt{20191124.1}.

To then access the build number in one of the pipeline's steps, the
\texttt{\$BUILD.BUILDNUMBER} variable can be read. When doing so from a
bash-based shell script, all dots are substituted with underscores. This
results in the variable name \texttt{\$BUILD\textunderscore BUILDNUMBER}.

\begin{listing}[H]
  \begin{minted}{YAML}
steps:
- displayName: 'Inject current build number into package.json'
  script: |
   echo "The current build number is: $BUILD_BUILDNUMBER"
   sed -i "s/1.0.0/1.0.0-$BUILD_BUILDNUMBER/g" package.json
  \end{minted}
  \caption{Injecting a date-based version number into the package.json file of
  a Node.js project using a script-based pipeline task.}%
  \label{listing:version_injection}
\end{listing}

Listing~\ref{listing:version_injection} shows the definition of a Azure DevOps
pipeline task. In it, the \texttt{sed} utility is used to find the version
string \texttt{1.0.0} and replace it with the string
\texttt{1.0.0-\textbf{build number}}. The question of why the string
\texttt{1.0.0} is prefixed to the version string might arise. Node.js demands
that all project use a SemVer version number. However additional information
can be postfixed. The postfix is also consulted when determining the newest
version of a Node.js package; \texttt{1.0.0-20190301.1} $<$
\texttt{1.0.0-20190301.2} $<$ \texttt{1.0.0-20200301.1}. Using this approach, a
Node.js project can take advantage of dynamic version numbers while preserving
the SemVer format.

Next to the actual software, the built Docker container image should also
receive a version number. This can be done by using the same variable.

\begin{listing}[H]
  \begin{minted}{YAML}
steps:
- task: Docker@2
  displayName: Build Docker image and push to repo
  inputs:
    containerRegistry: ''
    repository: frontend
    tags: |
     $(Build.BuildNumber)
  \end{minted}
  \caption{Tagging a Docker container image with a date-based version number
  using a pipeline task.}%
  \label{listing:image_version_tag}
\end{listing}

Listing~\ref{listing:image_version_tag} shows a Azure DevOps pipeline task that
builds a Docker container image and pushes it to an image repository. In line
8, the build number is specified as the image's tag. Thus a resulting image
will be tagged \texttt{frontend:20190809.1}.

\subsubsection{Conclusion}%
\label{ssub:Conclusion}
It can be concluded, that microservices can be split into two categories:
\textit{human interaction (consuming)} and \textit{machine interaction
(producing)}. For consuming the version number primarily serves a communicative
purpose by associating it with newly introduced features. In contrast,
producing microservices can use the version number to convey a technical
meaning. This however can conflict with the goal of continuously building and
deploying the service because the version number has to be set by hand. In the
end it has to be decided whether the version number really has to indicate a
break in the software's backward compatibility. If this is the case, a manual
versioning scheme like SemVer must be used. If not, a automatic versioning
scheme like CalVer should be used to further support the \ac{CI}/\ac{CD}
process.

\subsection{Evaluating XXX Versioning}%
\label{sub:Evaluating_XXX_Versioning}

\subsection{Advancing Continuous Deployment of Microservices using XXX Versioning}%
\label{sub:Advancing_Continuous_Deployment_of_Microservices_using_XXX_Versioning}

\subsection{Economic benefits of XXX Versioning}%
\label{sub:Economic_benefits_of_XXX_Versioning}

